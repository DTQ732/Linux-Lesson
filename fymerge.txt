Git手动Git - merge (1)


的名字

git-merge—将两个或多个开发历史合并在一起


剧情简介

git合并[n][——统计][——no-commit][——南瓜][——(不——)编辑)

[s <策略>][- x < strategy-option >] [s [< keyid >]]

(——不——rerere-autoupdate] [- m <味精>][<提交>…]

git合并 HEAD …

git合并,中止


描述

合并来自指定提交的更改(从它们的历史记录开始)
从当前分支分支)到当前分支。使用以下命令

由git拉入来自另一个存储库的更改，可以由手动将一个分支中的更改合并到另一个分支中。假设存在以下历史记录，当前分支为“master”:
一个——- b - c的话题
/
D - - e - - - - - - f - g的主人

然后，“git合并主题”将重播在主题分支上所做的更改
偏离主元(即主元)。， E)直到当前提交(C)在主服务器上，且

将结果与两个父提交的名称一起记录在一个新的提交中

以及来自用户描述更改的日志消息。


一个——- b - c的话题

/ \

D - - e - - f - g - h的主人


出于历史原因，支持第二种语法( HEAD …)。

不要在命令行或新脚本中使用它。它与git相同

合并-m <提交>…


第三个语法(“git merge——abort”)只能在merge之后运行

导致冲突。git merge——abort将中止合并进程并尝试执行

重建合并前的状态。但是，如果有未提交的更改时

合并开始了(特别是当那些变更在之后被进一步修改的时候)

在某些情况下，中止将无法进行

重构原始的(合并前的)变更。因此:


警告:不鼓励使用非零散的未提交更改运行git merge:

虽然有可能，但它可能会让你处于一种难以摆脱的状态

冲突的情况。


选项

————no-commit提交

执行合并并提交结果。此选项可用于覆盖

——no-commit。


使用——no-commit执行合并，但假装合并失败，不执行

自动提交，让用户有机会检查和进一步调整合并

结果之前。


——- e, no-edit编辑

在进一步提交成功的机械合并之前调用编辑器

编辑自动生成的合并消息，以便用户可以解释和

证明合并。——no-edit选项可用于接受

自动生成的消息(通常不鼓励这样做)。编辑(或-e)

选项仍然是有用的，如果你给一个草稿消息与-m选项

要在编辑器中编辑它。


旧的脚本可能依赖于不允许用户访问的历史行为

编辑合并日志消息。它们运行时将看到一个打开的编辑器

git合并。为了更容易地调整这些脚本以适应更新的行为，

环境变量GIT_MERGE_AUTOEDIT一开始可以设置为no

它们。


- - - ff

当合并以快进方式解析时，只更新分支指针，

不创建合并提交。这是默认的行为。


——no-ff

创建一个合并提交，即使合并以快进方式解析。这是

合并带注释(可能有签名)标记时的默认行为。


——ff-only

拒绝合并并以非零状态退出，除非当前磁头是

已经更新或合并可以作为快进解决。


——日志(= < n >),没有日志

除了分支名之外，还要用一行来填充日志消息

来自正在合并的实际提交的最多的描述。另请参阅

git-fmt-merge-msg (1)。


使用——no-log不会列出实际提交时的一行描述

合并。


,stat - n - no-stat

在合并结束时显示一个差异。微分方程也由

配置选项merge.stat。


使用-n或——no-stat在合并结束时不显示差异。


————no-squash南瓜

生成工作树和索引状态，就像真正发生了合并一样(除了

，但实际上不做提交，移动头部，

或者记录$GIT_DIR/MERGE_HEAD(以创建下一个git提交命令)

合并提交)。这允许您在。的基础上创建单个提交

当前的分支，其效果与合并另一个分支(或更多in)相同

章鱼的例子)。


使用——no-壁球执行合并并提交结果。这个选项可以是

用来压制，南瓜。


- s <策略>,策略= <策略>

使用给定的合并策略;可以提供多次以指定它们吗

按顺序他们应该被审判。如果没有-s选项，则使用内置列表

而使用of策略(在合并单个策略时使用git merge-recursive)

头，git合并-章鱼否则)。


- x <选项>,strategy-option = <选项>

将合并策略特定的选项传递给合并策略。


————no-verify-signatures verify-signatures

验证正在合并的提交具有良好和可信的GPG签名

中止合并，以防他们不这样做。


——总结——没有摘要

与——stat和——no-stat同义;这些是不赞成的，将被删除

未来。


q,安静

安静地运作。意味着,没有任何进展。


- v,详细

是冗长的。


——进步,没有进步

明确地打开/关闭进度。如果两者都没有指定，则显示进度

如果标准错误连接到终端。注意不是所有的都合并

战略可以支持进度报告。


- s (< keyid >), gpg-sign (= < keyid >)

对合并提交结果进行gpg签名。keyid参数是可选的

默认提交人身份;如果指定，则必须将其粘附到

没有空格的选项。


- m <味精>

将提交消息设置为用于合并提交(如果是的话)

创建)。


如果——log被指定，提交的短日志将被合并

附加到指定的消息。


可以使用git fmt-merge-msg命令提供良好的默认值

自动的git合并调用。自动化消息可以包含分支

描述。


——不——rerere-autoupdate

允许rerere机制使用结果更新索引

如果可能，自动解决冲突。


——中止

终止当前的冲突解决过程，并尝试重新构造

pre-merge状态。


如果合并开始时存在未提交的工作树更改，

git merge——在某些情况下，abort将无法重构这些更改。

因此，建议总是在之前提交或隐藏您的更改

运行git合并。


git merge——异常终止等同于git重置——合并合并时的MERGE_HEAD

礼物。


<提交>…

提交，通常是其他分支的头，以合并到我们的分支。指定

一个以上的提交将与两个以上的父类合并

(被亲切地称为“章鱼合并”)。


如果命令行没有提交，合并远程跟踪

当前分支配置为用作其上游的分支。看到

还有本手册页的配置部分。


当指定FETCH_HEAD(并且没有其他提交)时，记录的分支

.git/FETCH_HEAD文件，由前面的git fetch调用进行合并

合并到当前分支。


PRE-MERGE检查

在应用外部更改之前，您应该使自己的工作处于良好的状态

本地提交，所以如果有冲突，它不会被重击。另请参阅

git-stash (1)。本地时，git pull和git merge将停止，不做任何事情

未提交的更改与git拉/git合并可能需要的文件重叠

更新。


为了避免在合并提交中记录不相关的更改，可以使用git pull和git merge

如果在索引中注册了与

头承诺。(一个例外是当更改的索引项处于该状态时

那已经是合并的结果了。)


如果所有指定的提交都已经是HEAD的祖先，那么git merge将提前退出

上面写着“已更新”。


快速合并

通常当前的分支头是已命名的commit的祖先。这是

最常见的情况，特别是从git拉调用:您正在跟踪一个

上游存储库，您没有提交任何本地更改，现在您想要提交

更新到更新的上游版本。在这种情况下，不需要新的提交

存储合并的历史记录;相反，头(以及索引)被更新

指向指定的提交，而不创建额外的合并提交。


可以使用—no-ff选项抑制这种行为。


真正的融合

除非在快进合并(见上)中，要合并的分支必须是

通过将它们都作为父类的合并提交将它们绑定在一起。


合并版本协调来自所有要合并的分支的更改

提交后，您的头、索引和工作树将更新到它。它是

只要在工作树中没有修改，就可以修改

重叠;更新将保存它们。


当不清楚如何协调更改时，会发生以下情况:


1. 头指针保持不变。


2. MERGE_HEAD引用被设置为指向另一个分支头。


3.在索引文件和您的

工作树。


4. 对于冲突路径，索引文件最多记录三个版本:阶段1

存储来自共同祖先的版本、来自HEAD的阶段2和阶段3

从MERGE_HEAD(可以使用git ls-files -u查看各个阶段)。的

工作树文件包含“合并”程序的结果;例如我家

使用熟悉的冲突标记合并结果<<< === >>>。


5. 没有进行其他更改。特别是你的本地修改

在开始合并之前，它们的索引项将保持不变

保持原样，也就是匹配头部。


如果你尝试合并，结果导致了复杂的冲突，想要重新开始，

可以使用git merge——abort进行恢复。


合并标签

在合并带注释(可能还有签名)的标记时，Git总是创建一个merge

即使可以进行快进合并，也要提交，并提交消息模板

是用标记消息准备的。此外，如果标记已签名，则

签名检查被报告为消息模板中的注释。参见git -

标签(1)。


当您想要集成工作，并最终提交时

要被标记，例如与上游发布点同步，您可能不希望这样做

进行不必要的合并提交。


在这种情况下，您可以自己“打开”标签，然后将其提交给git merge，

或者只在你自己没有工作的时候才通过。如。


git获取来源

git合并v1.2.3 ^ 0

git合并——只包含ff1.2.3版本


如何呈现冲突

在合并期间，将更新工作树文件以反映

合并。在对共同祖先版本所做的更改中，没有重叠

1(换句话说，你改变了文件的一个区域，而另一边却没有改变

区域完整，反之亦然)将逐字地合并到最终结果中。当

双方都对同一个区域进行了更改，但是Git不能随机选择一个

并要求你通过离开双方所做的来解决问题

那个地区。


默认情况下，Git使用的风格与“merge”程序使用的风格相同

RCS套件呈现这样一个冲突的大块，像这样:


下面是一些与公共代码没有变化的代码行

祖先，或彻底解决，因为只有一方改变了。

< < < < < < <你:sample.txt

解决冲突是困难的;

让我们去购物。

=======

Git使冲突解决变得容易。

> > > > > > >他们:sample.txt

这是另一行，它是完全解析或未修改的。


对发生冲突变化的区域用标记标记出来

<<<<<<<， =======，和>>>>>>>。在======= =之前的部分通常是您的

之后的部分通常是他们的部分。


默认格式在冲突区域不显示原始格式。

你不知道有多少行被删除，并被Barbie的评语所取代

你的身边。你唯一能说的是，你的一方想说这很难

你更愿意去购物，而对方却声称购物很容易。


可以通过设置“merge.conflict . style”来使用另一种样式。

配置变量为“diff3”。在“diff3”风格中，上述冲突可能看起来

是这样的:


下面是一些与公共代码没有变化的代码行

祖先，或彻底解决，因为只有一方改变了。

< < < < < < <你:sample.txt

解决冲突是困难的;

让我们去购物。

|||||||

解决冲突是困难的。

=======

Git使冲突解决变得容易。

> > > > > > >他们:sample.txt

这是另一行，它是完全解析或未修改的。


除了< < < < < < < = = = = = = =,,> > > > > > >标记,它使用另一个| | | | | | |

后跟原始文本的标记。你可以看出，原来只是

陈述了一个事实，而你的一方简单地屈服于这个陈述并放弃了

另一方试图采取更积极的态度。你有时可以上来

用更好的分辨率观看原图。


如何解决冲突

看到冲突后，你可以做两件事:


·决定不合并。您需要的惟一清理是重置索引文件

向头部承诺反转2。并整理工作树所作的改动

2. 和3。git merge——可以使用abort。


·解决冲突。Git将在工作树中标记冲突。编辑

文件成形，git将它们添加到索引中。使用git提交盖章

这笔交易。


你可以用一些工具来解决冲突:


·使用合并工具。git合并工具来启动一个图形合并工具

完成合并。


·看看差异。git diff将显示一个三向diff，并突出显示更改

来自HEAD和MERGE_HEAD两个版本。


·查看每个分支的差异。git log——merge -p 将会显示

首先是HEAD版本，然后是MERGE_HEAD版本。


·看看原件。文件名显示了通用的祖先git

show:2:filename显示头版本，git显示:3:filename显示

MERGE_HEAD版本。


例子

·在当前分支的基础上合并分支的修复和增强，形成一个

章鱼合并:


$ git合并修复增强


·合并分支淘汰到当前分支，使用我们的合并策略:


$ git合并-我们的过时了


·将分支maint合并到当前分支中，但不进行新的提交

自动:


$ git合并——不提交维护


当您希望包含对合并的进一步更改时，可以使用此选项

想要编写自己的合并提交消息。


你应该避免滥用这个选项来偷偷进行实质性的改变

一个合并提交。小的修正，如碰撞释放/版本名称将是

可以接受的。


合并策略

合并机制(git merge和git pull命令)允许后端合并

使用-s选项选择策略。有些策略也可以自行其是

选项，可以通过给-X

git拉。


解决

这只能解决两个头(即当前的分支和另一个分支)

你从)使用一个3-路归并演算法。它试图仔细探测

交叉合并含糊不清，通常被认为是安全和快速的。


递归

这只能解决两个头使用3路归并算法。当有

一个以上的共同祖先可以用于3路合并，它创建一个

合并的共同祖先树，并将其用作参考树

三通合并。据报告，这将导致更少的合并冲突

而不会因为对实际的合并提交进行测试而导致错误

Linux 2.6内核开发历史。此外，这可以检测和处理

合并涉及重命名。这是在提取or时的默认合并策略

合并一个分支。


递归策略可以采取以下几种策略:


我们的

这个选项强制冲突块自动解决干净

有利于我们的版本。来自另一个不冲突的树的更改

我们这边是反映合并的结果。对于二进制文件，则

全部内容从我方拿走。


这不应该与我们的合并策略相混淆，我们的合并策略并不会混淆

甚至可以看看另一棵树包含了什么。它丢弃一切

另一棵树做到了，它宣告我们的历史包含了所有发生的事情

它。


他们的

这是我们的对立面。


耐心

有了这个选项，合并递归会多花一点时间来避免

有时由于不重要的匹配行(例如，

来自不同函数的大括号)。当要合并的分支时使用此方法

有广泛的分歧。参见git-diff(1)——patience(耐心)。


diff-algorithm =[耐心| |最小直方图| myers)

告诉合并递归使用不同的diff算法，这可以帮助

避免由于不重要的匹配行(例如

来自不同函数的大括号)。参见git-diff(1)——diff-algorithm。


ignore-space-change、ignore-all-space ignore-space-at-eol

将具有指定类型的空白更改的行视为未更改

为了一个三方合并。空格更改与其他更改混合在一起

对一行的更改不会被忽略。参见git-diff(1) -b、-w和

——ignore-space-at-eol。


·如果他们的版本只在一行中引入空格变化，我们的

版本使用;


·如果我们的版本引入了空格变化，但是他们的版本

包括一个实质性的变化，他们的版本被使用;


·否则，合并将以通常的方式进行。


renormalize

这将运行文件的所有三个阶段的虚拟签出和签入

在解决三方合并时。此选项将在何时使用

用不同的干净过滤器或行尾合并分支

规范化规则。参见“用不同的分支合并”

“在gitattributes(5)中检入/检出属性”获取详细信息。


no-renormalize

禁用重正化选项。这将覆盖合并。重整

配置变量。


rename-threshold = < n >

控制用于重命名检测的相似阈值。另请参阅

git-diff (1) - m。


子树(= <路径>)

此选项是一种更高级的子树策略，其中

策略是对两棵树如何进行移位以匹配进行猜测

合并时互相支持。相反，指定的路径是带前缀的(或

从一开始剥离)，使两棵树的形状匹配。


章鱼

这解决了两个以上的情况，但拒绝做一个复杂的

合并需要手动解析。它主要是用来

将主题分支捆绑在一起。这是默认的合并策略

拉动或合并多个分支。


我们的

这将解析任意数量的头，但是合并的结果树是

总是当前的分支头，有效地忽略所有的变化

所有其他分支。它是用来取代旧的发展

侧枝的历史。注意，这与-Xours选项不同

递归归并策略。


子树

这是一个改进的递归策略。当树A和B合并时，如果B

对应于a的一个子树，首先调整B来匹配该树

结构A，而不是读取树在同一水平。这

对共同的祖先树也做了调整。


与使用3路归并的策略(包括默认的递归)，如果a

两个分支上都做了更改，但稍后在其中一个分支上恢复

合并后的结果会有改变;有些人发现这种行为

让人困惑。这是因为只考虑了头和合并基

在执行合并时，不是各个提交。合并算法

因此，将返回的更改视为根本没有更改，并替换为

修改版本。


配置

merge.conflictStyle

指定将冲突块写入工作树的样式

在合并文件。默认值是“merge”，它显示了一个<<<<<<< <冲突

标记，一方所做的更改，a =====标记，另一方所做的更改

一边，然后是>>>>>>>标记。另一种样式“diff3”添加了|||||||

标记和====标记前的原始文本。


merge.defaultToUpstream

如果在没有任何提交参数的情况下调用merge，则合并上游分支

通过使用当前分支存储的最后一个观察值为其配置

在他们的远程跟踪分支。分支的值。

分支>。合并远程分支的名称。

分支>。远程被咨询，然后他们被映射通过

遥远。<远程>。获取到相应的远程跟踪分支，并且

这些跟踪分支的提示被合并。


merge.ff

默认情况下，Git在合并提交时不会创建额外的合并提交

它是当前提交的后代。而是电流的尖端

分支是快进。当设置为false时，这个变量告诉Git

在这种情况下创建一个额外的合并提交(相当于——no-ff)

选项从命令行)。当设置为only时，只能这样快进

允许合并(相当于从

命令行)。


merge.branchdesc

除了分支名称之外，还要用分支填充日志消息

与它们相关联的描述文本。默认值为false。


merge.log

除分支名称外，最多使用

指定实际提交的单行描述的数量

被合并。默认为false, true是20的同义词。


merge.renameLimit

执行重命名检测时要考虑的文件数量

合并;如果未指定，则默认为diff.renameLimit的值。


merge.renormalize

告诉Git存储库中文件的规范表示已经更改

随着时间的推移(例如，更早地提交以CRLF行结尾的记录文本文件，但是

最近的使用LF行结束)。在这样的存储库中，Git可以转换

在执行merge to之前，以提交形式记录的数据

减少不必要的冲突。有关更多信息，请参见“合并”一节

具有不同签入/签出属性的分支“在gitattributes中”(5)。


merge.stat

属性处是否打印ORIG_HEAD与合并结果之间的差异

合并结束。真正的默认。


merge.tool

控制git-mergetool使用哪个合并工具(1)。下面的列表显示

有效的内置值。任何其他值都被视为自定义合并工具

并要求相应的合并工具。<工具>。定义cmd变量。


·araxis


·公元前


·bc3


·codecompare


·deltawalker


·diffmerge


·扩散


·ecmerge


·出现


·gvimdiff


·gvimdiff2


·gvimdiff3


·kdiff3


·融合


·opendiff


·p4merge


·tkdiff


·tortoisemerge


·vimdiff


·vimdiff2


·vimdiff3


·winmerge


·xxdiff


merge.verbosity

控制递归合并策略显示的输出量。0级

如果检测到冲突，除了最后的错误消息外，不输出任何内容。

第1级只输出冲突，第2级输出冲突和文件更改。5级

以上输出调试信息。默认级别是2。可以

被GIT_MERGE_VERBOSITY环境变量覆盖。


合并。<司机> . name

为自定义低级合并驱动程序定义人可读的名称。看到

详情gitattributes (5)。


合并。<司机> .driver

定义实现自定义低级合并驱动程序的命令。看到

详情gitattributes (5)。


合并。<司机> .recursive

指定执行内部合并时要使用的低级合并驱动程序

之间的共同祖先。详见gitattributes(5)。


分支。<名称> .mergeOptions

设置合并到分支。语法和支持

选项与git merge的选项相同，但是选项值包含

目前不支持空白字符。


另请参阅

git-fmt-merge-msg(1)， git-pull(1)， gitattributes(5)， git-reset(1)， git-diff(1)，

git-ls-files(1)， git-add(1)， git-rm(1)， git-mergetool(1)


GIT

git(1)套件的一部分


Git 2.7.4 11/27/2018 Git - merge (1)
